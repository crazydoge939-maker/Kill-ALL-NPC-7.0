-- Основные переменные
local isKilling = false
local killInterval = 5
local lastKillTime = 0
local runService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Список NPC, которых не нужно убивать
local doNotKillList = {
	["DJ"] = true,
	["Bounty Hunter"] = true,
	["Mysterious Seller"] = true,
	["Fruit Dealer"] = true
}

local specialNPCs = {
	["Elf Traveler"] = true,
	["Demon"] = true,
	["Halloween Hell:GRIM"] = true,
	["Alien Protector"] = true,
	["King Small Trollge"] = true,
	["DUMMYTROLLGEOVERPAIN"] = true,
	["Paiful Star"] = true,
	["Mimic"] = true,



	["Troll-096"] = true,
	["Trollge King"] = true,
	["Corruption"] = true,
	["The Roofs"] = true,
	["Space Eater"] = true,
	["Red Nemesis"] = true,
	["Paladin"] = true,
	["Ophaenem"] = true,
	["Santa NK-1"] = true,
}

local npcAppearanceTimes = {} -- {["NPCName"] = time}
local npcDisplayStates = {} -- {["NPCName"] = {type="green"|"yellow", time=timestamp}}
local npcNameGuis = {} -- таблица для хранения GUI над NPC

local isEnabled = true -- состояние режима (включено/выключено)

-- Создаем GUI
local player = game.Players.LocalPlayer
local PlayerGui = player:WaitForChild("PlayerGui")
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "KillerGUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = PlayerGui

local Frame = Instance.new("Frame")
Frame.Size = UDim2.new(0, 300, 0, 450)
Frame.Position = UDim2.new(0, 20, 0, 20)
Frame.BackgroundColor3 = Color3.fromRGB(40, 44, 52)
Frame.BorderSizePixel = 0
Frame.Parent = ScreenGui
local UIStroke = Instance.new("UICorner")
UIStroke.CornerRadius = UDim.new(0, 12)
UIStroke.Parent = Frame

local UIGradient = Instance.new("UIGradient")
UIGradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 54, 62)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(30, 34, 42))
}
UIGradient.Parent = Frame

local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, 0, 0, 30)
Title.BackgroundTransparency = 1
Title.Text = "Auto Killer"
Title.Font = Enum.Font.GothamBold
Title.TextSize = 20
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.Parent = Frame

local ToggleButton = Instance.new("TextButton")
ToggleButton.Size = UDim2.new(0, 120, 0, 40)
ToggleButton.Position = UDim2.new(0, 20, 0, 50)
ToggleButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
ToggleButton.Font = Enum.Font.GothamBold
ToggleButton.TextSize = 16
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.Text = "Start Kill"
local buttonCorner = Instance.new("UICorner")
buttonCorner.CornerRadius = UDim.new(0, 8)
buttonCorner.Parent = ToggleButton
ToggleButton.Parent = Frame

local KillCountLabel = Instance.new("TextLabel")
KillCountLabel.Size = UDim2.new(1, -40, 0, 430) -- Кол-во строк
KillCountLabel.Position = UDim2.new(0, 20, 0, 100)
KillCountLabel.BackgroundTransparency = 1
KillCountLabel.Text = "Жертвы:\n"
KillCountLabel.TextWrapped = true
KillCountLabel.TextXAlignment = Enum.TextXAlignment.Left
KillCountLabel.TextYAlignment = Enum.TextYAlignment.Top
KillCountLabel.Font = Enum.Font.Gotham
KillCountLabel.TextSize = 20
KillCountLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
KillCountLabel.Parent = Frame

local toggleModeButton = Instance.new("TextButton")
toggleModeButton.Size = UDim2.new(0, 120, 0, 40)
toggleModeButton.Position = UDim2.new(0, 150, 0, 50)
toggleModeButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
toggleModeButton.Font = Enum.Font.GothamBold
toggleModeButton.TextSize = 16
toggleModeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleModeButton.Text = "Выкл подсветку"
local buttonCorner = Instance.new("UICorner")
buttonCorner.CornerRadius = UDim.new(0, 8)
buttonCorner.Parent = toggleModeButton
toggleModeButton.Parent = Frame

-- Линия прогресса расположена ниже логов
local ProgressBackground = Instance.new("Frame")
ProgressBackground.Size = UDim2.new(1, -40, 0, 10)
ProgressBackground.Position = UDim2.new(0, 20, 0, 30)
ProgressBackground.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
ProgressBackground.BorderSizePixel = 0
local progressCorner = Instance.new("UICorner")
progressCorner.CornerRadius = UDim.new(0, 5)
progressCorner.Parent = ProgressBackground
ProgressBackground.Parent = Frame

local ProgressBar = Instance.new("Frame")
ProgressBar.Size = UDim2.new(0, 0, 1, 0)
ProgressBar.BackgroundColor3 = Color3.fromRGB(0, 200, 0)
ProgressBar.BorderSizePixel = 0
local progressInnerCorner = Instance.new("UICorner")
progressInnerCorner.CornerRadius = UDim.new(0, 5)
ProgressBar.Parent = ProgressBackground

local function createNameGui(npc)
	local billboardGui = Instance.new("BillboardGui")
	billboardGui.Name = "NPCNameGui"
	billboardGui.Adornee = npc
	billboardGui.Size = UDim2.new(0, 75, 0, 30)
	billboardGui.StudsOffset = Vector3.new(0, 2, 0)
	billboardGui.AlwaysOnTop = true

	local textLabel = Instance.new("TextLabel")
	textLabel.Size = UDim2.new(1, 0, 1, 0)
	textLabel.BackgroundTransparency = 1
	textLabel.Text = npc.Name
	textLabel.TextColor3 = Color3.new(1, 1, 1)
	textLabel.TextStrokeTransparency = 0
	textLabel.TextScaled = true
	textLabel.Font = Enum.Font.GothamBold
	textLabel.Parent = billboardGui

	billboardGui.Parent = npc
	npcNameGuis[npc] = billboardGui

	-- Начальная прозрачность в зависимости от режима
	if not isEnabled then
		billboardGui.Enabled = false
	else
		billboardGui.Enabled = true
	end
end

local function toggleKilling()
	isKilling = not isKilling
	if isKilling then
		ToggleButton.Text = "Stop Kill"
		ToggleButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
		lastKillTime = tick()
	else
		ToggleButton.Text = "Start Kill"
		ToggleButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
	end
end

ToggleButton.MouseButton1Click:Connect(toggleKilling)

local function findHumanoids()
	local npcs = {}
	for _, v in pairs(workspace:GetDescendants()) do
		if v:IsA("Humanoid") and v.Parent and v.Parent:FindFirstChildOfClass("Humanoid") then
			if not game.Players:GetPlayerFromCharacter(v.Parent) then
				table.insert(npcs, v.Parent)
			end
		end
	end
	return npcs
end

local npcHighlights = {} -- таблица для хранения подсветки всех NPC

local function updateHighlights()
	local npcs = findHumanoids()
	for _, npc in pairs(npcs) do
		if npc then
			local highlight = npcHighlights[npc]
			if not highlight then
				highlight = Instance.new("Highlight")
				highlight.Name = "Highlight"
				highlight.Adornee = npc
				-- установка цвета
				if doNotKillList[npc.Name] then
					highlight.FillColor = Color3.fromRGB(0, 85, 0)
					highlight.OutlineColor = Color3.fromRGB(0, 255, 0)
				elseif specialNPCs[npc.Name] then
					highlight.FillColor = Color3.fromRGB(255, 85, 0)
					highlight.OutlineColor = Color3.fromRGB(255, 255, 0)
				else
					highlight.FillColor = Color3.fromRGB(85, 0, 0)
					highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
				end
				highlight.Parent = npc
				npcHighlights[npc] = highlight

				-- при создании, если режим выключен, делаем подсветку прозрачной
				if not isEnabled then
					highlight.FillTransparency = 1
					highlight.OutlineTransparency = 1
				else
					highlight.FillTransparency = 0
					highlight.OutlineTransparency = 0
				end
			end
			-- обновляем статус подсветки
			if doNotKillList[npc.Name] or specialNPCs[npc.Name] then
				npcHighlights[npc].Enabled = true
			else
				npcHighlights[npc].Enabled = true
			end
			if not npcNameGuis[npc] then
				createNameGui(npc)
			end
		end
	end
end

local lineFolder = Instance.new("Folder", workspace)
lineFolder.Name = "PlayerToNPCLines"

local function createLine(npc)
	local attachment0 = Instance.new("Attachment")
	local attachment1 = Instance.new("Attachment")

	attachment0.Parent = workspace
	attachment1.Parent = workspace

	local beam = Instance.new("Beam")
	beam.Attachment0 = attachment0
	beam.Attachment1 = attachment1

	local lineData = {
		Beam = beam,
		Attachment0 = attachment0,
		Attachment1 = attachment1,
		TargetPos0 = Vector3.new(),
		TargetPos1 = Vector3.new()
	}

	-- Устанавливаем прозрачность в зависимости от режима
	if not isEnabled then
		lineData.Beam.Transparency = NumberSequence.new(1)
	else
		lineData.Beam.Transparency = NumberSequence.new(0)
	end

	-- Устанавливаем цвет линии в зависимости от NPC
	if npc and npc.Name then
		if doNotKillList[npc.Name] then
			beam.Color = ColorSequence.new(Color3.fromRGB(0, 255, 0))
		elseif specialNPCs[npc.Name] then
			beam.Color = ColorSequence.new(Color3.fromRGB(255, 255, 0))
		else
			beam.Color = ColorSequence.new(Color3.fromRGB(255, 0, 0))
		end
	else
		beam.Color = ColorSequence.new(Color3.fromRGB(255, 0, 0))
	end

	beam.Width0 = 0.2
	beam.Width1 = 0.2
	beam.Transparency = NumberSequence.new(0.5)
	beam.Parent = lineFolder

	return lineData
end

local function isNpcAlive(npc)
	local humanoid = npc:FindFirstChildOfClass("Humanoid")
	local hrp = npc:FindFirstChild("HumanoidRootPart")
	return humanoid and humanoid.Health > 0 and hrp
end

local npcLines = {}
local smoothingFactor = 1

local function onNewNPC(npc)
	local lineData = createLine(npc)
	if not isEnabled then
		lineData.Beam.Transparency = NumberSequence.new(1)
	else
		lineData.Beam.Transparency = NumberSequence.new(0)
	end
	table.insert(npcLines, lineData)
end

local function updateLines()
	local playerCharacter = LocalPlayer.Character
	if not playerCharacter then return end
	local hrp = playerCharacter:FindFirstChild("HumanoidRootPart")
	if not hrp then return end
	local playerPos = hrp.Position

	for npc, highlight in pairs(npcHighlights) do
		if highlight.Enabled then
			if isNpcAlive(npc) then
				local lineData = npcLines[npc]
				if not lineData then
					if isEnabled then
						lineData = createLine(npc)
					else
						-- Если режим выключен, создаем линию, но делаем ее прозрачной
						lineData = createLine(npc)
						lineData.Beam.Transparency = NumberSequence.new(1)
					end
					npcLines[npc] = lineData
				end
				if lineData then
					lineData.TargetPos0 = playerPos
					local npcHrp = npc:FindFirstChild("HumanoidRootPart")
					if npcHrp then
						lineData.TargetPos1 = npcHrp.Position
					end
					local currentPos0 = lineData.Attachment0.WorldPosition
					local newPos0 = currentPos0:Lerp(lineData.TargetPos0, smoothingFactor)
					lineData.Attachment0.WorldPosition = newPos0

					local currentPos1 = lineData.Attachment1.WorldPosition
					local newPos1 = currentPos1:Lerp(lineData.TargetPos1, smoothingFactor)
					lineData.Attachment1.WorldPosition = newPos1
				end
			else
				if npcLines[npc] then
					npcLines[npc].Beam:Destroy()
					npcLines[npc].Attachment0:Destroy()
					npcLines[npc].Attachment1:Destroy()
					npcLines[npc] = nil
				end
				if npcHighlights[npc] then
					npcHighlights[npc].Enabled = false
				end
			end
		else
			if npcLines[npc] then
				npcLines[npc].Beam:Destroy()
				npcLines[npc].Attachment0:Destroy()
				npcLines[npc].Attachment1:Destroy()
				npcLines[npc] = nil
			end
		end
	end

	-- Удаление линий для отключенных NPC
	for npc, lineData in pairs(npcLines) do
		if not npcHighlights[npc] or not npcHighlights[npc].Enabled then
			lineData.Beam:Destroy()
			lineData.Attachment0:Destroy()
			lineData.Attachment1:Destroy()
			npcLines[npc] = nil
		end
	end
end

local function removeLine(npc)
	local lineData = npcLines[npc]
	if lineData then
		lineData.Beam:Destroy()
		lineData.Attachment0:Destroy()
		lineData.Attachment1:Destroy()
		npcLines[npc] = nil
	end
end

KillCountLabel.RichText = true

coroutine.wrap(function()
	while true do
		wait(1)
		updateHighlights()
		updateLines()
	end
end)()

local function toggleMode()
	isEnabled = not isEnabled
	if isEnabled then
		toggleModeButton.Text = "Выкл подсветку"
		toggleModeButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
		-- Включаем подсветку и GUI
		for _, highlight in pairs(npcHighlights) do
			highlight.FillTransparency = 0
			highlight.OutlineTransparency = 0
		end
		for _, lineData in pairs(npcLines) do
			lineData.Beam.Transparency = NumberSequence.new(0)
		end
	else
		toggleModeButton.Text = "Включить подсветку"
		toggleModeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
		-- Выключаем подсветку и делаем линии прозрачными
		for _, highlight in pairs(npcHighlights) do
			highlight.FillTransparency = 1
			highlight.OutlineTransparency = 1
		end
		for _, lineData in pairs(npcLines) do
			lineData.Beam.Transparency = NumberSequence.new(1)
		end
	end

	-- Обновляем видимость GUI для всех NPC
	for _, gui in pairs(npcNameGuis) do
		gui.Enabled = isEnabled
	end
end

toggleModeButton.MouseButton1Click:Connect(toggleMode)

local killedHumanoidsCount = {}
KillCountLabel.RichText = true

local previousCount = {} -- для сравнения текущего и прошлого количества
local function updateKillCount()
	killedHumanoidsCount = {}
	local currentTime = tick()

	-- собираем текущие NPC
	local currentNPCs = {}
	for _, npc in pairs(findHumanoids()) do
		local name = npc.Name
		currentNPCs[name] = true

		-- если NPC впервые — запоминаем время появления
		if not npcDisplayStates[name] then
			npcDisplayStates[name] = {type="green", time = currentTime}
		end
		-- считаем
		if killedHumanoidsCount[name] then
			killedHumanoidsCount[name] = killedHumanoidsCount[name] + 1
		else
			killedHumanoidsCount[name] = 1
		end
	end

	-- сравниваем старое и новое количество для определения изменения
	for name, _ in pairs(previousCount) do
		if not currentNPCs[name] then
			-- NPC исчез — можно убрать его состояние
			npcDisplayStates[name] = nil
		end
	end

	-- для новых NPC или измененного количества обновляем состояние
	for name, count in pairs(killedHumanoidsCount) do
		if not previousCount[name] then
			-- новый NPC — подсветка зеленым
			npcDisplayStates[name] = {type="green", time = currentTime}
		elseif count ~= previousCount[name] then
			-- изменение количества — подсветка желтым
			npcDisplayStates[name] = {type="yellow", time = currentTime}
		end
	end

	-- сохраняем текущий счет для следующего обновления
	previousCount = table.clone(killedHumanoidsCount)

	-- формируем текст с тегами
	local displayText = "Жертвы:\n"
	local currentTime = tick()
	for name, count in pairs(killedHumanoidsCount) do
		local state = npcDisplayStates[name]
		local elapsed = currentTime - (state and state.time or currentTime)
		local progress = math.clamp(elapsed / 10, 0, 1)

		local color
		if state then
			if state.type == "green" then
				-- плавно меняем с зеленого в белый
				local R = math.floor(0 + (255 - 0) * progress)
				local G = math.floor(255 + (255 - 255) * progress)
				local B = math.floor(0 + (255 - 0) * progress)
				color = string.format('rgb(%d,%d,%d)', R, G, B)
			elseif state.type == "yellow" then
				-- плавно меняем с желтого в белый
				local R = math.floor(255 + (255 - 255) * progress)
				local G = math.floor(255 + (255 - 255) * progress)
				local B = math.floor(0 + (255 - 0) * progress)
				color = string.format('rgb(%d,%d,%d)', R, G, B)
			end
		else
			-- по дефолту — белый
			color = 'rgb(255,255,255)'
		end

		local fontTagStart = string.format('<font color="%s">', color)
		local fontTagEnd = '</font>'

		local lineStr = fontTagStart .. name
		if count > 1 then
			lineStr = lineStr .. " x" .. count
		end
		lineStr = lineStr .. fontTagEnd .. "\n"

		displayText = displayText .. lineStr
	end

	KillCountLabel.Text = displayText
end

local function updateTextColors()
	local currentTime = tick()

	for name, timeAppeared in pairs(npcAppearanceTimes) do
		local elapsed = currentTime - timeAppeared
		local progress = math.clamp(elapsed / 10, 0, 1) -- 10 секунд на смену цвета
		local startColor = Color3.fromRGB(0, 255, 0) -- зеленый
		local endColor = Color3.fromRGB(255, 255, 255) -- белый
		local currentColor = Color3.new(
			startColor.R + (endColor.R - startColor.R) * progress,
			startColor.G + (endColor.G - startColor.G) * progress,
			startColor.B + (endColor.B - startColor.B) * progress
		)

		-- Обновляем цвет текста для строки с этим NPC
		local textLines = string.split(KillCountLabel.Text, "\n")

		for i, line in ipairs(textLines) do
			if line:sub(1, #name) == name then
				-- Обновляем цвет этой строки
				-- Для этого понадобится использовать TextColorSequence или менять цвет всей строки
				-- Но TextLabel в Roblox не поддерживает изменение цвета отдельных строк.
				-- Поэтому проще перерисовать весь текст, меняя цвет, или использовать отдельные TextLabels.
				-- Для простоты сделаю так:
				-- Перезадаем весь текст с цветом, выделяя нужные строки цветом (сложно, проще так)
				-- или создадим отдельный TextLabel для каждой строки (рекомендуется).
			end
		end
	end
end

coroutine.wrap(function()
	while true do
		wait(0.5)
		updateKillCount()
	end
end)()

local function killMovingHumanoids()
	local npcs = findHumanoids()
	for _, npc in pairs(npcs) do
		if isNpcAlive(npc) then
			local name = npc.Name
			-- Проверка, есть ли NPC в списке не убивать
			if doNotKillList[name] then
				continue
			end

			local humanoid = npc:FindFirstChildOfClass("Humanoid")
			local hrp = npc:FindFirstChild("HumanoidRootPart")
			local velocity = hrp.AssemblyLinearVelocity
			local speed = velocity.Magnitude
			if speed > 1 then
				local highlight = npcHighlights[npc]
				if highlight then
					highlight.Enabled = true
				end
				humanoid.Health = 0
				-- удаляем линию сразу после убийства
				if npcLines[npc] then
					npcLines[npc].Beam:Destroy()
					npcLines[npc].Attachment0:Destroy()
					npcLines[npc].Attachment1:Destroy()
					npcLines[npc] = nil
				end
			end
		end
	end
end

-- Основной цикл
runService.Heartbeat:Connect(function()
	if isKilling then
		local currentTime = tick()
		local elapsed = currentTime - lastKillTime
		local progress = math.min(elapsed / killInterval, 1)
		ProgressBar.Size = UDim2.new(progress, 0, 1, 0)

		if elapsed >= killInterval then
			killMovingHumanoids()
			lastKillTime = currentTime
			updateKillCount()
		end
	else
		ProgressBar.Size = UDim2.new(0, 0, 1, 0)
	end

	local playerCharacter = LocalPlayer.Character
	if not playerCharacter then return end
	local hrp = playerCharacter:FindFirstChild("HumanoidRootPart")
	if not hrp then return end
	local playerPos = hrp.Position

	for npc, highlight in pairs(npcHighlights) do
		if highlight.Enabled then
			if isNpcAlive(npc) then
				local lineData = npcLines[npc]
				if not lineData then
					lineData = createLine()
					npcLines[npc] = lineData
				end
				-- Обновляем целевые позиции
				lineData.TargetPos0 = playerPos
				local npcHrp = npc:FindFirstChild("HumanoidRootPart")
				if npcHrp then
					lineData.TargetPos1 = npcHrp.Position
				end
				-- Плавное перемещение Attachment к целевым позициям
				local currentPos0 = lineData.Attachment0.WorldPosition
				local newPos0 = currentPos0:Lerp(lineData.TargetPos0, smoothingFactor)
				lineData.Attachment0.WorldPosition = newPos0

				local currentPos1 = lineData.Attachment1.WorldPosition
				local newPos1 = currentPos1:Lerp(lineData.TargetPos1, smoothingFactor)
				lineData.Attachment1.WorldPosition = newPos1
			else
				-- NPC умер или исчез — удаляем линию и подсветку
				if npcLines[npc] then
					npcLines[npc].Beam:Destroy()
					npcLines[npc].Attachment0:Destroy()
					npcLines[npc].Attachment1:Destroy()
					npcLines[npc] = nil
				end
				if npcHighlights[npc] then
					npcHighlights[npc].Enabled = false
				end
			end
		else
			-- подсветка отключена, удаляем линию
			if npcLines[npc] then
				npcLines[npc].Beam:Destroy()
				npcLines[npc].Attachment0:Destroy()
				npcLines[npc].Attachment1:Destroy()
				npcLines[npc] = nil
			end
		end
	end

	-- Удаляем линии для NPC, которых больше нет или не подсвечены
	for npc, lineData in pairs(npcLines) do
		if not npcHighlights[npc] or not npcHighlights[npc].Enabled then
			lineData.Beam:Destroy()
			lineData.Attachment0:Destroy()
			lineData.Attachment1:Destroy()
			npcLines[npc] = nil
		end
	end
end)

-- Перетаскивание GUI
local dragging = false
local dragStart
local startPos

Frame.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true
		dragStart = input.Position
		startPos = Frame.Position
	end
end)

Frame.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = false
	end
end)

Frame.InputChanged:Connect(function(input)
	if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local delta = input.Position - dragStart
		Frame.Position = startPos + UDim2.new(0, delta.X, 0, delta.Y)
	end
end)
